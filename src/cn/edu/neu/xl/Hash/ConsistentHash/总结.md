## 原理
先构造一个长度为232的整数环（这个环被称为一致性Hash环），根据节点名称的Hash值（其分布为[0, 232-1]）将服务器节点放置在这个Hash环上，然后根据数据的Key值计算得到其Hash值（其分布也为[0, 232-1]），接着在Hash环上**顺时针**查找距离这个Key值的Hash值最近的服务器节点，完成Key到服务器的映射查找。
 
## Hash值重新计算
String重写的hashCode()方法在一致性Hash算法并不适用，因为不同节点在环上区间不均匀，造成不均衡。String的hashCode()方法却会产生负数。
CRC32_HASH、FNV1_32_HASH、KETAMA_HASH等，其中KETAMA_HASH是默认的MemCache推荐的一致性Hash算法，用别的Hash算法也可以，比如FNV1_32_HASH算法的计算效率就会高一些。

##虚拟节点
不带虚拟节点的一致性哈希算法会存在**负载不均**的问题
比如说有Hash环上有A、B、C三个服务器节点，分别有100个请求会被路由到相应服务器上。现在在A与B之间增加了一个节点D，这导致了原来会路由到B上的部分节点被路由到了D上，这样A、C上被路由到的请求明显多于B、D上的，原来三个服务器节点上均衡的负载被打破了。某种程度上来说，这失去了负载均衡的意义，因为负载均衡的目的本身就是为了使得目标服务器均分所有的请求。


## 更多方法的学习参考 
http://www.cnblogs.com/xrq730/p/5186728.html
